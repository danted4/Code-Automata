/**
 * Mock CLI Adapter
 *
 * Simulates CLI responses without making actual API calls.
 * Use this for UI development and testing to conserve credits.
 */

import * as fs from 'fs';
import * as path from 'path';
import {
  CLIAdapter,
  CLIConfig,
  CLICapabilities,
  CLIConfigSchema,
  ExecuteRequest,
  StreamMessage,
} from './base';

export class MockCLIAdapter implements CLIAdapter {
  name = 'mock';
  displayName = 'Mock CLI (Testing)';

  private config: CLIConfig | null = null;
  private activeThreads = new Map<string, MockThreadSession>();
  private threadToWorkingDir = new Map<string, string>(); // Track working dir per thread

  getConfigSchema(): CLIConfigSchema {
    return {
      fields: [
        {
          name: 'mode',
          label: 'Simulation Mode',
          type: 'select',
          options: [
            { value: 'smart', label: 'Smart (Detailed Simulation)' },
            { value: 'rush', label: 'Rush (Quick Simulation)' },
          ],
          default: 'smart',
          description: 'Controls the verbosity of simulated responses',
        },
        {
          name: 'delay',
          label: 'Response Delay (ms)',
          type: 'number',
          default: 500,
          description: 'Artificial delay between simulated messages',
        },
      ],
    };
  }

  async initialize(config: CLIConfig): Promise<void> {
    this.config = config;
    console.log('[MockAdapter] Initialized with config:', {
      mode: config.mode,
      cwd: config.cwd,
    });
  }

  async *execute(request: ExecuteRequest): AsyncIterable<StreamMessage> {
    if (!this.config) {
      throw new Error('MockAdapter not initialized');
    }

    const threadId = request.threadId || this.generateThreadId();

    // Create or get thread session
    let session = this.activeThreads.get(threadId);
    if (!session) {
      session = {
        threadId,
        messages: [],
        startedAt: Date.now(),
      };
      this.activeThreads.set(threadId, session);
    }

    // Simulate system message
    yield {
      type: 'system',
      timestamp: Date.now(),
      data: {
        message: 'Mock agent initialized',
        tools: ['read_file', 'write_file', 'bash', 'search'],
        mode: this.config.mode || 'smart',
      },
      threadId,
    };

    // Simulate delay
    await this.delay(500);

    // Detect if this is a planning prompt
    const isPlanningPrompt = request.prompt.includes('PLANNING PHASE');
    const isQuestionGeneration = request.prompt.includes('Question Generation');

    // Simulate assistant thinking
    yield {
      type: 'assistant',
      timestamp: Date.now(),
      data: {
        message: `[MOCK] Processing: "${request.prompt.substring(0, 50)}..."`,
        thinking: isPlanningPrompt
          ? 'Analyzing requirements and generating planning output...'
          : 'Analyzing the request and determining the best approach...',
      },
      threadId,
    };

    await this.delay(1000);

    // If this is a planning prompt, return appropriate JSON
    if (isPlanningPrompt) {
      if (isQuestionGeneration) {
        // Generate mock questions
        yield {
          type: 'assistant',
          timestamp: Date.now(),
          data: {
            message: JSON.stringify({
              questions: [
                {
                  id: 'q1',
                  question: 'Which framework should we use for the UI?',
                  options: ['React', 'Vue', 'Angular', 'Vanilla JS'],
                  required: true,
                  order: 1,
                },
                {
                  id: 'q2',
                  question: 'How should we handle state management?',
                  options: ['Redux', 'Context API', 'Zustand', 'MobX'],
                  required: true,
                  order: 2,
                },
                {
                  id: 'q3',
                  question: 'What testing framework should we use?',
                  options: ['Jest', 'Vitest', 'Mocha', 'Playwright'],
                  required: false,
                  order: 3,
                },
              ],
            }, null, 2),
          },
          threadId,
        };
      } else {
        // Generate mock plan
        yield {
          type: 'assistant',
          timestamp: Date.now(),
          data: {
            message: JSON.stringify({
              plan: `# Implementation Plan

## Overview
This is a mock implementation plan generated by the Mock adapter for testing purposes.

## Technical Approach
- Use modern best practices
- Follow existing code patterns
- Ensure proper error handling

## Implementation Steps
1. Set up project structure
2. Create core components
3. Implement business logic
4. Add tests
5. Document changes

## Files to Modify
- src/components/new-feature.tsx
- src/lib/api/endpoints.ts
- tests/new-feature.test.ts

## Testing Strategy
- Unit tests for core logic
- Integration tests for API endpoints
- E2E tests for critical user flows

## Potential Issues
- May need to handle edge cases
- Performance considerations for large datasets

## Success Criteria
- All tests pass
- Feature works as expected
- No regressions in existing functionality`,
            }, null, 2),
          },
          threadId,
        };
      }

      await this.delay(500);

      // Return success result
      yield {
        type: 'result',
        timestamp: Date.now(),
        data: {
          success: true,
          message: '[MOCK] Planning completed successfully!',
          summary: isQuestionGeneration
            ? 'Generated 3 clarifying questions'
            : 'Generated comprehensive implementation plan',
        },
        threadId,
      };

      session.messages.push({
        prompt: request.prompt,
        response: isQuestionGeneration ? 'Mock questions' : 'Mock plan',
        timestamp: Date.now(),
      });

      return; // Exit early for planning prompts
    }

    // Detect if this is a subtask generation prompt
    const isSubtaskGeneration = request.prompt.includes('SUBTASK GENERATION');

    if (isSubtaskGeneration) {
      // Generate random number of dev subtasks (5-15)
      const numDevSubtasks = Math.floor(Math.random() * 11) + 5; // 5 to 15
      const numQASubtasks = Math.floor(numDevSubtasks * 0.6); // QA subtasks ~60% of dev count
      const subtasks = [];

      // Generate dev subtasks
      for (let i = 1; i <= numDevSubtasks; i++) {
        subtasks.push({
          id: `subtask-dev-${i}`,
          content: `[MOCK] Implement step ${i} of the plan - this is a simulated development subtask with detailed instructions about what needs to be done.`,
          label: `Step ${i}`,
          type: 'dev',
          activeForm: `Working on Step ${i}`,
        });
      }

      // Generate QA subtasks
      for (let i = 1; i <= numQASubtasks; i++) {
        subtasks.push({
          id: `subtask-qa-${i}`,
          content: `[MOCK] Verify implementation step ${i} - this is a simulated QA subtask that validates the corresponding development work.`,
          label: `Verify Step ${i}`,
          type: 'qa',
          activeForm: `Verifying Step ${i}`,
        });
      }

      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] Breaking down the plan into ${numDevSubtasks} development subtasks and ${numQASubtasks} QA verification subtasks...`,
        },
        threadId,
      };

      await this.delay(2000);

      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: JSON.stringify({ subtasks }, null, 2),
        },
        threadId,
      };

      await this.delay(500);

      yield {
        type: 'result',
        timestamp: Date.now(),
        data: {
          success: true,
          message: `[MOCK] Generated ${numDevSubtasks} dev subtasks and ${numQASubtasks} QA subtasks successfully!`,
        },
        threadId,
      };

      session.messages.push({
        prompt: request.prompt,
        response: `Generated ${numDevSubtasks} dev + ${numQASubtasks} QA subtasks`,
        timestamp: Date.now(),
      });

      return; // Exit early for subtask generation
    }

    // Detect if this is a subtask execution prompt
    const isSubtaskExecution = request.prompt.includes('Execute the following subtask');

    if (isSubtaskExecution) {
      // Extract subtask ID and label from prompt
      const labelMatch = request.prompt.match(/\*\*Subtask:\*\* (.+)/);
      const label = labelMatch ? labelMatch[1] : 'Unknown';
      
      // Generate subtask ID from label (e.g., "Step 1" -> "subtask-dev-1")
      // For now, use the label as the identifier
      const subtaskId = label.replace(/\s+/g, '-').toLowerCase();

      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] Starting execution of: ${label}`,
        },
        threadId,
      };

      await this.delay(1000);

      // Actually create/read the attendance file at the root of the worktree
      // Use the thread's working directory if available, otherwise fall back to config
      const workingDir = this.threadToWorkingDir.get(threadId) || this.config?.cwd || process.cwd();
      const attendanceFile = path.join(workingDir, 'subtask-attendance.txt');
      
      // Ensure directory exists
      const dir = path.dirname(attendanceFile);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      yield {
        type: 'tool',
        timestamp: Date.now(),
        data: {
          tool: 'bash',
          parameters: { command: `cat ${attendanceFile} 2>/dev/null || echo ""` },
          result: fs.existsSync(attendanceFile) 
            ? `File exists with ${fs.readFileSync(attendanceFile, 'utf-8').split('\n').filter(l => l).length} entries`
            : 'File will be created',
        },
        threadId,
      };

      await this.delay(800);

      // Actually append subtask ID to the attendance file
      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] Recording attendance for ${subtaskId}...`,
        },
        threadId,
      };

      await this.delay(1500);

      // ACTUALLY WRITE THE FILE
      const timestamp = new Date().toISOString();
      const entry = `[${subtaskId}] Completed at ${timestamp}\n`;
      
      try {
        fs.appendFileSync(attendanceFile, entry, 'utf-8');
        console.log(`[MockAdapter] Attendance recorded: ${attendanceFile}`);
      } catch (e) {
        console.error(`[MockAdapter] Failed to write attendance: ${e}`);
      }

      yield {
        type: 'tool',
        timestamp: Date.now(),
        data: {
          tool: 'bash',
          parameters: { 
            command: `echo "[${subtaskId}] Completed at ${timestamp}" >> ${attendanceFile}` 
          },
          result: '[MOCK] Attendance recorded successfully',
        },
        threadId,
      };

      await this.delay(500);

      // Simulate success
      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] âœ“ Completed: ${label} (${subtaskId})`,
        },
        threadId,
      };

      await this.delay(300);

      yield {
        type: 'result',
        timestamp: Date.now(),
        data: {
          success: true,
          message: `[MOCK] Subtask "${label}" completed successfully!`,
          filesModified: [attendanceFile],
        },
        threadId,
      };

      session.messages.push({
        prompt: request.prompt,
        response: `Executed subtask: ${label}`,
        timestamp: Date.now(),
      });

      return; // Exit early for subtask execution
    }

    await this.delay(1000);

    // Simulate tool usage
    yield {
      type: 'tool',
      timestamp: Date.now(),
      data: {
        tool: 'search',
        parameters: { query: 'relevant code' },
        result: '[MOCK] Found 5 relevant files',
      },
      threadId,
    };

    await this.delay(800);

    // Simulate more assistant work
    yield {
      type: 'assistant',
      timestamp: Date.now(),
      data: {
        message: '[MOCK] I found the relevant code and am implementing the solution...',
      },
      threadId,
    };

    await this.delay(1200);

    // Simulate tool usage (file write)
    yield {
      type: 'tool',
      timestamp: Date.now(),
      data: {
        tool: 'write_file',
        parameters: { path: 'src/example.ts' },
        result: '[MOCK] File written successfully',
      },
      threadId,
    };

    await this.delay(500);

    // Simulate final result
    yield {
      type: 'result',
      timestamp: Date.now(),
      data: {
        success: true,
        message: '[MOCK] Task completed successfully!',
        summary: 'This is a simulated response from the Mock adapter. No real API calls were made.',
        filesModified: ['src/example.ts'],
        context: request.context ? 'Context was injected from memory' : undefined,
      },
      threadId,
    };

    // Store message in session
    session.messages.push({
      prompt: request.prompt,
      response: 'Mock response',
      timestamp: Date.now(),
    });
  }

  async createThread(workingDir: string): Promise<string> {
    const threadId = this.generateThreadId();
    console.log('[MockAdapter] Created thread:', threadId, 'in', workingDir);
    // Store the working directory for this thread
    this.threadToWorkingDir.set(threadId, workingDir);
    return threadId;
  }

  async resumeThread(threadId: string): Promise<void> {
    console.log('[MockAdapter] Resuming thread:', threadId);
    // No-op for mock
  }

  async stopThread(threadId: string): Promise<void> {
    console.log('[MockAdapter] Stopping thread:', threadId);
    this.activeThreads.delete(threadId);
  }

  getCapabilities(): CLICapabilities {
    return {
      supportsThreads: true,
      supportsModes: ['smart', 'rush'],
      maxConcurrentAgents: 12,
      supportsPermissions: true,
    };
  }

  private generateThreadId(): string {
    return `mock-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

interface MockThreadSession {
  threadId: string;
  messages: Array<{
    prompt: string;
    response: string;
    timestamp: number;
  }>;
  startedAt: number;
}
