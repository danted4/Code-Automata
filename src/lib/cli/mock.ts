/**
 * Mock CLI Adapter
 *
 * Simulates CLI responses without making actual API calls.
 * Use this for UI development and testing to conserve credits.
 */

import {
  CLIAdapter,
  CLIConfig,
  CLICapabilities,
  CLIConfigSchema,
  ExecuteRequest,
  StreamMessage,
} from './base';

export class MockCLIAdapter implements CLIAdapter {
  name = 'mock';
  displayName = 'Mock CLI (Testing)';

  private config: CLIConfig | null = null;
  private activeThreads = new Map<string, MockThreadSession>();

  getConfigSchema(): CLIConfigSchema {
    return {
      fields: [
        {
          name: 'mode',
          label: 'Simulation Mode',
          type: 'select',
          options: [
            { value: 'smart', label: 'Smart (Detailed Simulation)' },
            { value: 'rush', label: 'Rush (Quick Simulation)' },
          ],
          default: 'smart',
          description: 'Controls the verbosity of simulated responses',
        },
        {
          name: 'delay',
          label: 'Response Delay (ms)',
          type: 'number',
          default: 500,
          description: 'Artificial delay between simulated messages',
        },
      ],
    };
  }

  async initialize(config: CLIConfig): Promise<void> {
    this.config = config;
    console.log('[MockAdapter] Initialized with config:', {
      mode: config.mode,
      cwd: config.cwd,
    });
  }

  async *execute(request: ExecuteRequest): AsyncIterable<StreamMessage> {
    if (!this.config) {
      throw new Error('MockAdapter not initialized');
    }

    const threadId = request.threadId || this.generateThreadId();

    // Create or get thread session
    let session = this.activeThreads.get(threadId);
    if (!session) {
      session = {
        threadId,
        messages: [],
        startedAt: Date.now(),
      };
      this.activeThreads.set(threadId, session);
    }

    // Simulate system message
    yield {
      type: 'system',
      timestamp: Date.now(),
      data: {
        message: 'Mock agent initialized',
        tools: ['read_file', 'write_file', 'bash', 'search'],
        mode: this.config.mode || 'smart',
      },
      threadId,
    };

    // Simulate delay
    await this.delay(500);

    // Detect if this is a planning prompt
    const isPlanningPrompt = request.prompt.includes('PLANNING PHASE');
    const isQuestionGeneration = request.prompt.includes('Question Generation');

    // Simulate assistant thinking
    yield {
      type: 'assistant',
      timestamp: Date.now(),
      data: {
        message: `[MOCK] Processing: "${request.prompt.substring(0, 50)}..."`,
        thinking: isPlanningPrompt
          ? 'Analyzing requirements and generating planning output...'
          : 'Analyzing the request and determining the best approach...',
      },
      threadId,
    };

    await this.delay(1000);

    // If this is a planning prompt, return appropriate JSON
    if (isPlanningPrompt) {
      if (isQuestionGeneration) {
        // Generate mock questions
        yield {
          type: 'assistant',
          timestamp: Date.now(),
          data: {
            message: JSON.stringify({
              questions: [
                {
                  id: 'q1',
                  question: 'Which framework should we use for the UI?',
                  options: ['React', 'Vue', 'Angular', 'Vanilla JS'],
                  required: true,
                  order: 1,
                },
                {
                  id: 'q2',
                  question: 'How should we handle state management?',
                  options: ['Redux', 'Context API', 'Zustand', 'MobX'],
                  required: true,
                  order: 2,
                },
                {
                  id: 'q3',
                  question: 'What testing framework should we use?',
                  options: ['Jest', 'Vitest', 'Mocha', 'Playwright'],
                  required: false,
                  order: 3,
                },
              ],
            }, null, 2),
          },
          threadId,
        };
      } else {
        // Generate mock plan
        yield {
          type: 'assistant',
          timestamp: Date.now(),
          data: {
            message: JSON.stringify({
              plan: `# Implementation Plan

## Overview
This is a mock implementation plan generated by the Mock adapter for testing purposes.

## Technical Approach
- Use modern best practices
- Follow existing code patterns
- Ensure proper error handling

## Implementation Steps
1. Set up project structure
2. Create core components
3. Implement business logic
4. Add tests
5. Document changes

## Files to Modify
- src/components/new-feature.tsx
- src/lib/api/endpoints.ts
- tests/new-feature.test.ts

## Testing Strategy
- Unit tests for core logic
- Integration tests for API endpoints
- E2E tests for critical user flows

## Potential Issues
- May need to handle edge cases
- Performance considerations for large datasets

## Success Criteria
- All tests pass
- Feature works as expected
- No regressions in existing functionality`,
            }, null, 2),
          },
          threadId,
        };
      }

      await this.delay(500);

      // Return success result
      yield {
        type: 'result',
        timestamp: Date.now(),
        data: {
          success: true,
          message: '[MOCK] Planning completed successfully!',
          summary: isQuestionGeneration
            ? 'Generated 3 clarifying questions'
            : 'Generated comprehensive implementation plan',
        },
        threadId,
      };

      session.messages.push({
        prompt: request.prompt,
        response: isQuestionGeneration ? 'Mock questions' : 'Mock plan',
        timestamp: Date.now(),
      });

      return; // Exit early for planning prompts
    }

    // Detect if this is a subtask generation prompt
    const isSubtaskGeneration = request.prompt.includes('SUBTASK GENERATION');

    if (isSubtaskGeneration) {
      // Generate random number of subtasks (5-15)
      const numSubtasks = Math.floor(Math.random() * 11) + 5; // 5 to 15
      const subtasks = [];

      for (let i = 1; i <= numSubtasks; i++) {
        subtasks.push({
          id: `subtask-${i}`,
          content: `[MOCK] Implement step ${i} of the plan - this is a simulated subtask with detailed instructions about what needs to be done.`,
          label: `Step ${i}`,
          activeForm: `Working on Step ${i}`,
        });
      }

      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] Breaking down the plan into ${numSubtasks} actionable subtasks...`,
        },
        threadId,
      };

      await this.delay(2000);

      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: JSON.stringify({ subtasks }, null, 2),
        },
        threadId,
      };

      await this.delay(500);

      yield {
        type: 'result',
        timestamp: Date.now(),
        data: {
          success: true,
          message: `[MOCK] Generated ${numSubtasks} subtasks successfully!`,
        },
        threadId,
      };

      session.messages.push({
        prompt: request.prompt,
        response: `Generated ${numSubtasks} mock subtasks`,
        timestamp: Date.now(),
      });

      return; // Exit early for subtask generation
    }

    // Detect if this is a subtask execution prompt
    const isSubtaskExecution = request.prompt.includes('Execute the following subtask');

    if (isSubtaskExecution) {
      // Extract subtask label from prompt
      const labelMatch = request.prompt.match(/\*\*Subtask:\*\* (.+)/);
      const label = labelMatch ? labelMatch[1] : 'Unknown';

      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] Starting execution of: ${label}`,
        },
        threadId,
      };

      await this.delay(1000);

      // Simulate reading files
      yield {
        type: 'tool',
        timestamp: Date.now(),
        data: {
          tool: 'read_file',
          parameters: { path: 'src/example.ts' },
          result: '[MOCK] File read successfully',
        },
        threadId,
      };

      await this.delay(800);

      // Simulate writing code
      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] Implementing changes for ${label}...`,
        },
        threadId,
      };

      await this.delay(1500);

      yield {
        type: 'tool',
        timestamp: Date.now(),
        data: {
          tool: 'write_file',
          parameters: { path: 'src/example.ts' },
          result: '[MOCK] File updated successfully',
        },
        threadId,
      };

      await this.delay(500);

      // Simulate success
      yield {
        type: 'assistant',
        timestamp: Date.now(),
        data: {
          message: `[MOCK] âœ“ Completed: ${label}`,
        },
        threadId,
      };

      await this.delay(300);

      yield {
        type: 'result',
        timestamp: Date.now(),
        data: {
          success: true,
          message: `[MOCK] Subtask "${label}" completed successfully!`,
        },
        threadId,
      };

      session.messages.push({
        prompt: request.prompt,
        response: `Executed subtask: ${label}`,
        timestamp: Date.now(),
      });

      return; // Exit early for subtask execution
    }

    await this.delay(1000);

    // Simulate tool usage
    yield {
      type: 'tool',
      timestamp: Date.now(),
      data: {
        tool: 'search',
        parameters: { query: 'relevant code' },
        result: '[MOCK] Found 5 relevant files',
      },
      threadId,
    };

    await this.delay(800);

    // Simulate more assistant work
    yield {
      type: 'assistant',
      timestamp: Date.now(),
      data: {
        message: '[MOCK] I found the relevant code and am implementing the solution...',
      },
      threadId,
    };

    await this.delay(1200);

    // Simulate tool usage (file write)
    yield {
      type: 'tool',
      timestamp: Date.now(),
      data: {
        tool: 'write_file',
        parameters: { path: 'src/example.ts' },
        result: '[MOCK] File written successfully',
      },
      threadId,
    };

    await this.delay(500);

    // Simulate final result
    yield {
      type: 'result',
      timestamp: Date.now(),
      data: {
        success: true,
        message: '[MOCK] Task completed successfully!',
        summary: 'This is a simulated response from the Mock adapter. No real API calls were made.',
        filesModified: ['src/example.ts'],
        context: request.context ? 'Context was injected from memory' : undefined,
      },
      threadId,
    };

    // Store message in session
    session.messages.push({
      prompt: request.prompt,
      response: 'Mock response',
      timestamp: Date.now(),
    });
  }

  async createThread(workingDir: string): Promise<string> {
    const threadId = this.generateThreadId();
    console.log('[MockAdapter] Created thread:', threadId, 'in', workingDir);
    return threadId;
  }

  async resumeThread(threadId: string): Promise<void> {
    console.log('[MockAdapter] Resuming thread:', threadId);
    // No-op for mock
  }

  async stopThread(threadId: string): Promise<void> {
    console.log('[MockAdapter] Stopping thread:', threadId);
    this.activeThreads.delete(threadId);
  }

  getCapabilities(): CLICapabilities {
    return {
      supportsThreads: true,
      supportsModes: ['smart', 'rush'],
      maxConcurrentAgents: 12,
      supportsPermissions: true,
    };
  }

  private generateThreadId(): string {
    return `mock-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

interface MockThreadSession {
  threadId: string;
  messages: Array<{
    prompt: string;
    response: string;
    timestamp: number;
  }>;
  startedAt: number;
}
