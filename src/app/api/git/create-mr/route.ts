/**
 * Create Merge Request / Pull Request API Route
 *
 * Creates a GitHub PR (via `gh`) for a task's worktree branch.
 * - Stages + commits uncommitted changes (if any)
 * - Pushes branch to origin
 * - Creates PR (or returns existing PR) and stores URL on task
 */

import { NextRequest, NextResponse } from 'next/server';
import { taskPersistence } from '@/lib/tasks/persistence';
import { getWorktreeManager } from '@/lib/git/worktree';
import { execFile } from 'child_process';

export const runtime = 'nodejs';

function run(cmd: string, args: string[], cwd: string): Promise<{ stdout: string; stderr: string }> {
  return new Promise((resolve, reject) => {
    execFile(
      cmd,
      args,
      { cwd, maxBuffer: 10 * 1024 * 1024 },
      (error, stdout, stderr) => {
        if (error) {
          const e = new Error(
            `${cmd} ${args.join(' ')} failed: ${String((stderr || stdout || '').trim()) || error.message}`
          );
          (e as any).cause = error;
          reject(e);
          return;
        }
        resolve({ stdout: String(stdout || ''), stderr: String(stderr || '') });
      }
    );
  });
}

function extractFirstUrl(text: string): string | null {
  const m = text.match(/https?:\/\/[^\s]+/);
  return m ? m[0] : null;
}

export async function POST(req: NextRequest) {
  try {
    const { taskId } = await req.json();
    if (!taskId || typeof taskId !== 'string') {
      return NextResponse.json({ error: 'taskId required' }, { status: 400 });
    }

    const task = await taskPersistence.loadTask(taskId);
    if (!task) return NextResponse.json({ error: 'Task not found' }, { status: 404 });

    if (!task.worktreePath || !task.branchName) {
      return NextResponse.json(
        { error: 'Task has no worktree/branch. Cannot create MR.' },
        { status: 400 }
      );
    }

    const manager = getWorktreeManager();
    const gitAvailable = await manager.verifyGitAvailable();
    if (!gitAvailable) {
      return NextResponse.json({ error: 'Git is not available' }, { status: 503 });
    }

    const baseBranch = await manager.getMainBranch();

    // Ensure gh exists and user is authenticated
    await run('gh', ['--version'], task.worktreePath).catch(() => {
      throw new Error('GitHub CLI (`gh`) not found. Install it to create a PR/MR.');
    });
    await run('gh', ['auth', 'status'], task.worktreePath).catch(() => {
      throw new Error('`gh` is not authenticated. Run `gh auth login` and retry.');
    });

    // If we already created one before, just return it (best-effort verify it still exists)
    if (task.mergeRequestUrl) {
      return NextResponse.json({ success: true, url: task.mergeRequestUrl, alreadyExists: true });
    }

    // Commit any uncommitted changes (PR requires pushed commits)
    const { stdout: porcelain } = await run('git', ['status', '--porcelain'], task.worktreePath);
    const hasUncommitted = porcelain.trim().length > 0;
    if (hasUncommitted) {
      await run('git', ['add', '-A'], task.worktreePath);
      const message = `code-auto: ${task.title || task.id} (${task.id})`;
      await run('git', ['commit', '-m', message], task.worktreePath).catch((e) => {
        throw new Error(
          `Failed to commit changes. Ensure git user.name/user.email are configured.\n${String(
            (e as Error).message || e
          )}`
        );
      });
    }

    // Push branch to origin
    await run('git', ['push', '-u', 'origin', 'HEAD'], task.worktreePath);

    // If PR already exists for this head, return it
    const { stdout: existingJson } = await run(
      'gh',
      ['pr', 'list', '--head', task.branchName, '--json', 'url', '--limit', '1'],
      task.worktreePath
    );
    try {
      const parsed = JSON.parse(existingJson) as Array<{ url?: string }>;
      const existingUrl = parsed?.[0]?.url;
      if (existingUrl) {
        task.mergeRequestUrl = existingUrl;
        task.updatedAt = Date.now();
        await taskPersistence.saveTask(task);
        return NextResponse.json({ success: true, url: existingUrl, alreadyExists: true });
      }
    } catch {
      // ignore parse errors and proceed to create
    }

    const title = `${task.title || 'Task'}: ${task.description?.slice(0, 60) || task.id}`.trim();
    const body = [
      `Task ID: ${task.id}`,
      '',
      task.description ? `Description:\n${task.description}` : '',
      '',
      'Generated by Code-Auto.',
    ]
      .filter(Boolean)
      .join('\n');

    const { stdout: createdOut } = await run(
      'gh',
      ['pr', 'create', '--title', title, '--body', body, '--base', baseBranch, '--head', task.branchName],
      task.worktreePath
    );

    const url = extractFirstUrl(createdOut);
    if (!url) {
      throw new Error(`Failed to parse PR URL from gh output:\n${createdOut}`);
    }

    task.mergeRequestUrl = url;
    task.updatedAt = Date.now();
    await taskPersistence.saveTask(task);

    return NextResponse.json({ success: true, url });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

